# 수업
## 컴포넌트의 생애
컴포넌트의 생애는 3단계로 구분된다.
**Mount(탄생, 화면에 나타나는 것), Update(변화, 업데이트(리렌더)), UnMount(죽음, 화면에서 사라짐)**

모든 리액트 컴포넌트는 동일한 생명주기를 거친다.
- 컴포넌트는 화면에 추가될 때 **마운트**된다.
- 컴포넌트는 일반적으로 상호작용에 대한 응답으로 새로운 props나 state를 수신하면 **업데이트**된다.
- 컴포넌트가 화면에서 제거되면 **마운트가 해제**된다.
컴포넌트는 **새로운 props나 state를 수신**하면 **업데이트**된다고 안내된다.
우린 지난주에 사용해봤다. (Counter App에서 상위 컴포넌트에서 하위 컴포넌트로 props를 주고, state 변화도 사용해봤다)

## React의 발전사
### class vs function
### 클래스형 컴포넌트의 장점

class 문법은 백엔드에서도 사용하고 있어서 정형화된 **개발 패턴**을 뽑아낼 수 있다.
협업에서 중요한 건 일관된 구조이기 때문에 어떻게 보면 협업에 적합한 클래스는 **어쩌면 클래스**이다.

컴포넌트 생애 전반에 디테일한 조절이 가능하다.
라이프 사이클을 통제, 관리하는 클래스 내부 함수 또는 메소드가 있다.

### 클래스형 컴포넌트의 단점
class 문법, 자바스크립트 특유의 this 문법, 컴포넌트 내부에서 사용하는 메소드, 개발 패턴(디자인 패턴이나 객체지향적 사고)에 대한 이해
이것들을 모르면 협업하기 어렵다.

라이프 사이클을 통제, 관리하는 클래스 내부 함수 또는 메소드가 있지만,
배우기 어렵다. 컴포넌트 생에 전반에 디테일한 조절을 하려면 컴포넌트 생애 전반을 이해하고 사용할 수 있는 사람이다.

## API를 받으면 컴포트는 어떻게 알죠?
**컴포넌트는 input이 같다면 output이 같은 함수**
그런데 이런 순수한 함수 로직으로는 한계가 있다.
바깥에서 **컴포넌트에 영향(Effect)**을 주고 싶다. (API를 주고받고 싶다)

fetch로 state 값을 바꾸면 state가 바뀌면서 컴포넌트를 다시 렌더링한다.
그럼 컴포넌트에 있는 로직이 실행되면서 fetch...state...렌더링... 반복한다.

우리는 외부의 영향을 받아서 딱 1번만 동기화 시키고 싶다.

**useEffect Hook**
useEffect는 외부의 효과를 랜더링과 분리하기 위해 존재한다.
이런 외부의 부수 효과는 useEffect에 감싸줘야한다는 말과 같은 의미이다.
외부 효과는 DOM 조작에 직접적으로 관여하지 않는다.

